<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agent Office Viz ‚Äî Dota-like Pixel</title>
  <style>
    body{margin:0;background:#0f172a;color:#e2e8f0;font-family:system-ui;padding:12px}
    h1{margin:0 0 6px;font-size:20px}.sub{color:#94a3b8;margin-bottom:8px}
    .hud{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
    button{background:#334155;color:#fff;border:1px solid #64748b;border-radius:8px;padding:7px 10px;cursor:pointer}
    #status{color:#cbd5e1;font-size:13px}
    canvas{display:block;max-width:1180px;width:100%;image-rendering:pixelated;border:2px solid #334155;border-radius:10px;background:#89a9c5}
  </style>
</head>
<body>
  <h1>üè¢ Agent Office Viz ‚Äî —É–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∏–º—É–ª—è—Ç–æ—Ä</h1>
  <div class="sub">Dota-like –ø–∏–∫—Å–µ–ª—å-—Å—Ç–∏–ª—å, –º–∞—Ä—à—Ä—É—Ç—ã –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π, —Ç–∞–π–º–µ—Ä—ã —Ä–∞–±–æ—Ç—ã/–∫—É—Ö–Ω–∏, —Ç—É–∞–ª–µ—Ç –∫–∞–∂–¥—ã–µ 2 —á–∞—Å–∞, –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Ä–∞–Ω–¥–æ–º–Ω–æ—Å—Ç—å.</div>
  <div class="hud">
    <button onclick="toggle()">‚èØ –°—Ç–∞—Ä—Ç/–ü–∞—É–∑–∞</button>
    <button onclick="tickOnce()">‚è≠ –®–∞–≥</button>
    <button onclick="resetSim()">üîÑ –°–±—Ä–æ—Å</button>
    <span id="status"></span>
  </div>
  <canvas id="game" width="1180" height="680"></canvas>

<script>
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');
ctx.imageSmoothingEnabled = false;

const agentsMeta = [
  ['Arthur','#60a5fa'],['Invoker','#a78bfa'],['Chen','#f472b6'],['Designer','#fb7185'],
  ['Tinker','#22d3ee'],['Oracle','#f43f5e'],['Io','#facc15'],['QA','#4ade80']
];

// spaces
const ROOM_Y = 570;
const rooms = Array.from({length:8},(_,i)=>({name:`–ö–æ–º–Ω–∞—Ç–∞ ${agentsMeta[i][0]}`, x:20+i*145, y:430, w:140, h:230, bed:[45+i*145,625]}));
const office = {name:'–û—Ñ–∏—Å', x:20, y:20, w:760, h:390};
const kitchen = {name:'–ö—É—Ö–Ω—è', x:800, y:20, w:360, h:280};
const toilet = {name:'–¢—É–∞–ª–µ—Ç', x:800, y:320, w:360, h:90};

const officeSeats = [
  [120,120],[220,120],[320,120],[420,120],[520,120],[620,120],[240,220],[420,220]
];
const kitchenSeats = [[860,90],[950,90],[1040,90],[900,200],[1030,200]];
const toiletSpots = [[860,365],[960,365],[1060,365]];

const PATH = {
  roomDoor:[740,430], officeDoor:[740,280], kitchenDoor:[800,170], toiletDoor:[800,365]
};

function lanePoint(base, lane){
  const offsets = [-18,-12,-6,0,6,12,18,24];
  return [base[0] + offsets[lane % offsets.length], base[1]];
}

let simMin = 9*60; // 09:00
let running=false, loopHandle;

function hm(m){const h=((m/60)|0)%24,mm=m%60;return `${String(h).padStart(2,'0')}:${String(mm).padStart(2,'0')}`}
function rnd(a){return a[(Math.random()*a.length)|0]}
function chance(p){return Math.random()<p}
function jitter([x,y],jx=8,jy=6){return [x+Math.random()*jx-jx/2,y+Math.random()*jy-jy/2]}

const events = [
  {text:'üìû –∑–≤–æ–Ω–æ–∫ –æ—Ç —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–æ–≤', p:0.02, effect:'room'},
  {text:'ü§ï –±–æ–ª–∏—Ç –≥–æ–ª–æ–≤–∞', p:0.018, effect:'kitchen'},
  {text:'‚òï –∑–∞—Ö–æ—Ç–µ–ª –∫–æ—Ñ–µ', p:0.03, effect:'kitchen'},
  {text:'üî• —Å—Ä–æ—á–Ω—ã–π —Ç–∏–∫–µ—Ç', p:0.05, effect:'office'},
  {text:'üí¨ —Å–∏–Ω–∫ —Å –∫–æ–ª–ª–µ–≥–æ–π', p:0.04, effect:'office'}
];

const agents = agentsMeta.map((m,i)=>(
  { id:m[0].toLowerCase(), name:m[0], color:m[1],
    x:rooms[i].x+70, y:ROOM_Y, vx:0, vy:0, speed:1.45 + Math.random()*0.35,
    target:null, path:[], zone:'room', seat:i,
    workLeft:0, kitchenLeft:0, toiletNeed:120, toiletLeft:0,
    bubble:'', bubbleUntil:0, state:'idle', personality:Math.random(),
    lastX:rooms[i].x+70, lastY:ROOM_Y, stuckFrames:0 }
));

function bubble(a,t,d=2200){a.bubble=t;a.bubbleUntil=performance.now()+d}

function setPath(a, points){ a.path = points.map(p=>[p[0],p[1]]); a.target = null; }
function goOffice(a, seatIdx){
  const lane = agents.indexOf(a);
  const seat = jitter(officeSeats[seatIdx%officeSeats.length],10,8);
  setPath(a,[lanePoint(PATH.roomDoor,lane), lanePoint(PATH.officeDoor,lane), seat]);
  a.zone='office'; a.state='walk';
}
function goRoom(a){
  const i = agents.indexOf(a);
  const home = [rooms[i].x+70 + (Math.random()*10-5), ROOM_Y + (Math.random()*6-3)];
  setPath(a,[lanePoint(PATH.officeDoor,i), lanePoint(PATH.roomDoor,i), home]);
  a.zone='room'; a.state='walk';
}
function goKitchen(a){
  const lane = agents.indexOf(a);
  const seat = jitter(rnd(kitchenSeats),10,8);
  setPath(a,[lanePoint(PATH.officeDoor,lane), lanePoint(PATH.kitchenDoor,lane), seat]);
  a.zone='kitchen'; a.state='walk';
}
function goToilet(a){
  const lane = agents.indexOf(a);
  const spot = jitter(rnd(toiletSpots),8,4);
  setPath(a,[lanePoint(PATH.officeDoor,lane), lanePoint(PATH.toiletDoor,lane), spot]);
  a.zone='toilet'; a.state='walk';
}

function assignBehaviors(){
  // frequent reposition / task checks each minute
  const hasTasks = chance(0.68);

  agents.forEach((a, i) => {
    a.toiletNeed -= 1;

    // forced toilet every 2 hours
    if (a.toiletNeed <= 0 && a.zone !== 'toilet') {
      goToilet(a); a.toiletLeft = 3 + (Math.random()*2|0); bubble(a,'üöª –∏–¥—É –≤ —Ç—É–∞–ª–µ—Ç',2000); a.toiletNeed = 120;
      return;
    }

    // random personal events
    const ev = events.find(e=>chance(e.p * (0.8 + a.personality*0.7)));
    if (ev && a.state !== 'walk') {
      bubble(a, ev.text, 2600);
      if (ev.effect==='kitchen') { goKitchen(a); a.kitchenLeft = 3 + (Math.random()*2|0); }
      else if (ev.effect==='office') { goOffice(a, (i+2)%officeSeats.length); a.workLeft = 15 + (Math.random()*30|0); }
      else { goRoom(a); }
      return;
    }

    // work timer max 45 min
    if (a.zone==='office' && a.workLeft>0) { a.workLeft -= 1; if (a.workLeft===0) { bubble(a,'‚è∞ 45 –º–∏–Ω —Ö–≤–∞—Ç–∏—Ç',1800); goRoom(a); } return; }
    // kitchen max 5 min
    if (a.zone==='kitchen' && a.kitchenLeft>0) { a.kitchenLeft -= 1; if (a.kitchenLeft===0) { bubble(a,'–≤–æ–∑–≤—Ä–∞—â–∞—é—Å—å',1400); goOffice(a, i); a.workLeft = 8 + (Math.random()*14|0); } return; }
    // toilet short
    if (a.zone==='toilet' && a.toiletLeft>0) { a.toiletLeft -= 1; if (a.toiletLeft===0) { bubble(a,'–≥–æ—Ç–æ–≤–æ',1200); goOffice(a, i); a.workLeft = 6 + (Math.random()*12|0); } return; }

    // normal flow
    if (hasTasks) {
      if (a.zone!=='office' || chance(0.25)) {
        goOffice(a, (i + (Math.random()*3|0)) % officeSeats.length);
        a.workLeft = 12 + (Math.random()*34|0); // <=45 controlled by decrement
        if (a.workLeft > 45) a.workLeft = 45;
        if (chance(0.2)) bubble(a,'–±–µ—Ä—É –∑–∞–¥–∞—á—É',1400);
      }
    } else {
      if (a.zone!=='room' || chance(0.35)) {
        goRoom(a);
        if (chance(0.25)) bubble(a,'–Ω–µ—Ç –∑–∞–¥–∞—á',1300);
      }
    }

    // group kitchen every 10 min
    if (simMin % 10 === 0 && chance(0.35)) {
      goKitchen(a);
      a.kitchenLeft = 2 + (Math.random()*3|0); // max 5
      if (a.kitchenLeft>5) a.kitchenLeft=5;
      bubble(a, rnd(['‚òï –∫—É—Ö–Ω—è','üí¨ –¥–µ–ª–∏–º—Å—è –æ–ø—ã—Ç–æ–º','üß† –æ–±—Å—É–∂–¥–∞–µ–º']), 2200);
    }
  });

  document.getElementById('status').textContent = `[${hm(simMin)}] ${hasTasks?'–í –æ—Ñ–∏—Å–µ –µ—Å—Ç—å –∑–∞–¥–∞—á–∏':'–ë—ç–∫–ª–æ–≥ –ø—É—Å—Ç'} ‚Ä¢ –ê–≥–µ–Ω—Ç—ã –¥–≤–∏–≥–∞—é—Ç—Å—è –ø–æ —Ç–∞–π–º–µ—Ä–∞–º –∏ —Å–ª—É—á–∞–π–Ω—ã–º —Å–æ–±—ã—Ç–∏—è–º`;
  simMin += 1;
}

function stepMove(a){
  if(!a.target && a.path.length) a.target = a.path.shift();
  if(!a.target){a.state='idle'; a.stuckFrames=0; return;}
  const dx=a.target[0]-a.x, dy=a.target[1]-a.y, d=Math.hypot(dx,dy);
  if(d<=a.speed){a.x=a.target[0];a.y=a.target[1];a.target=null; a.stuckFrames=0; return;}
  a.x += dx/d*a.speed; a.y += dy/d*a.speed; a.state='walk';

  const moved = Math.hypot(a.x-a.lastX, a.y-a.lastY);
  if(moved < 0.12) a.stuckFrames += 1; else a.stuckFrames = 0;
  a.lastX = a.x; a.lastY = a.y;

  // unstick: small side-step + skip hard choke waypoint
  if(a.stuckFrames > 24){
    a.x += (Math.random()*10-5);
    a.y += (Math.random()*8-4);
    if(a.path.length) a.target = a.path.shift();
    a.stuckFrames = 0;
    bubble(a,'–æ–±—Ö–æ–∂—É –ø—Ä–æ–±–∫—É',900);
  }
}

function avoidOverlap(){
  for(let i=0;i<agents.length;i++){
    for(let j=i+1;j<agents.length;j++){
      const a=agents[i], b=agents[j];
      const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy) || 0.001;
      const min=18;
      if(d<min){
        const push=(min-d)/2;
        const nx=dx/d, ny=dy/d;
        a.x -= nx*push; a.y -= ny*push;
        b.x += nx*push; b.y += ny*push;
      }
    }
  }
}

function drawFloor(x,y,w,h){
  ctx.fillStyle='#be9567'; ctx.fillRect(x,y,w,h);
  for(let i=0;i<w;i+=28){ctx.fillStyle=((i/28)&1)?'#b8895d':'#c89d6f';ctx.fillRect(x+i,y,14,h)}
  for(let j=0;j<h;j+=20){ctx.fillStyle='rgba(60,35,15,.16)';ctx.fillRect(x,y+j,w,2)}
}
function drawLabel(text,x,y){ctx.fillStyle='#e2e8f0';ctx.font='12px sans-serif';ctx.fillText(text,x,y)}

function drawComputers(){
  officeSeats.forEach(([x,y])=>{ctx.fillStyle='#1e293b';ctx.fillRect(x-16,y-10,32,12);ctx.fillStyle='#0ea5e9';ctx.fillRect(x-12,y-8,24,8);ctx.fillStyle='#6b7280';ctx.fillRect(x-9,y+3,18,4);});
}

function drawMap(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  drawFloor(office.x,office.y,office.w,office.h); ctx.strokeStyle='#1f2937'; ctx.lineWidth=4; ctx.strokeRect(office.x,office.y,office.w,office.h);
  drawFloor(kitchen.x,kitchen.y,kitchen.w,kitchen.h); ctx.strokeRect(kitchen.x,kitchen.y,kitchen.w,kitchen.h);
  drawFloor(toilet.x,toilet.y,toilet.w,toilet.h); ctx.strokeRect(toilet.x,toilet.y,toilet.w,toilet.h);
  drawFloor(20,430,1140,230); ctx.strokeRect(20,430,1140,230);

  drawLabel('–û–§–ò–°',32,42); drawLabel('–ö–£–•–ù–Ø',812,42); drawLabel('–¢–£–ê–õ–ï–¢',812,342); drawLabel('–ö–û–ú–ù–ê–¢–´',32,452);

  // furniture
  ctx.fillStyle='#475569'; ctx.fillRect(80,80,190,50); // rack
  ctx.fillStyle='#4b5563'; ctx.fillRect(95,250,220,70); // sofa
  ctx.fillStyle='#d9b57a'; ctx.fillRect(360,220,190,90); // table
  ctx.fillStyle='#93c5fd'; ctx.fillRect(570,230,170,70); // sofa2
  ctx.fillStyle='#94a3b8'; ctx.fillRect(820,70,85,120); // fridge
  ctx.fillStyle='#e2e8f0'; ctx.fillRect(930,90,200,44); // counter
  ctx.fillStyle='#cbd5e1'; ctx.fillRect(860,210,220,80); // kitchen table
  ctx.fillStyle='#f1f5f9'; ctx.fillRect(840,350,290,44); // toilet sinks

  drawComputers();

  // rooms beds + names
  rooms.forEach((r,i)=>{
    ctx.strokeRect(r.x,r.y,r.w,r.h);
    ctx.fillStyle='#93c5fd'; ctx.fillRect(r.bed[0],r.bed[1],70,24);
    drawLabel(agentsMeta[i][0], r.x+8, r.y+16);
  });
}

function drawBubble(a){
  if(!a.bubble || performance.now()>a.bubbleUntil) return;
  const txt=a.bubble;
  const w=Math.max(72, txt.length*6+10), h=20;
  const x=a.x-w/2, y=a.y-42;
  ctx.fillStyle='rgba(255,255,255,.95)'; ctx.fillRect(x,y,w,h);
  ctx.fillStyle='#0f172a'; ctx.font='10px sans-serif'; ctx.fillText(txt,x+5,y+13);
}
function drawTimer(a){
  let t='';
  if(a.zone==='office' && a.workLeft>0) t=`‚è≥${a.workLeft}–º`;
  if(a.zone==='kitchen' && a.kitchenLeft>0) t=`üçµ${a.kitchenLeft}–º`;
  if(a.zone==='toilet' && a.toiletLeft>0) t=`üöª${a.toiletLeft}–º`;
  if(!t) return;
  ctx.fillStyle='rgba(15,23,42,.85)'; ctx.fillRect(a.x-20,a.y-54,40,10);
  ctx.fillStyle='#f8fafc'; ctx.font='9px sans-serif'; ctx.fillText(t,a.x-18,a.y-46);
}
function drawAgent(a){
  const x=a.x|0,y=a.y|0;
  ctx.fillStyle='rgba(0,0,0,.22)'; ctx.fillRect(x-9,y+10,18,3);
  ctx.fillStyle='#111827'; ctx.fillRect(x-10,y-20,20,22); // body
  ctx.fillStyle=a.color; ctx.fillRect(x-8,y-27,16,9); // helmet/icon vibe
  ctx.fillStyle='#f8fafc'; ctx.fillRect(x-4,y-12,8,8); // face
  // walk legs animation
  const step = Math.floor(performance.now()/120)%2;
  ctx.fillStyle='#0f172a';
  if(step){ctx.fillRect(x-8,y+2,6,8);ctx.fillRect(x+2,y+1,6,8);} else {ctx.fillRect(x-8,y+1,6,8);ctx.fillRect(x+2,y+2,6,8);} 
  drawTimer(a); drawBubble(a);
}

function render(){
  drawMap();
  agents.forEach(stepMove);
  avoidOverlap();
  agents.forEach(drawAgent);
  requestAnimationFrame(render);
}

function loop(){ if(!running) return; assignBehaviors(); loopHandle=setTimeout(loop,1000); }
function toggle(){ running=!running; if(running) loop(); else clearTimeout(loopHandle); }
function tickOnce(){ assignBehaviors(); }
function resetSim(){
  running=false; clearTimeout(loopHandle); simMin=9*60;
  agents.forEach((a,i)=>{a.x=rooms[i].x+70; a.y=ROOM_Y; a.path=[]; a.target=null; a.zone='room'; a.workLeft=0; a.kitchenLeft=0; a.toiletNeed=120; a.toiletLeft=0; a.bubble='';});
  assignBehaviors();
}
window.toggle=toggle; window.tickOnce=tickOnce; window.resetSim=resetSim;
assignBehaviors(); render();
</script>
</body>
</html>